<html>
<head>

</head>
<body>

<button onclick="readMap()">olla2</button>


<script>
    function readMap(){
        xmlhttp = new XMLHttpRequest();
		xmlhttp.onreadystatechange = function() {
			if (this.readyState == 4 && this.status == 200) {
                jsonFile = JSON.parse(this.responseText);
				createGraph(jsonFile.elements);
			}
		};
		xmlhttp.open("GET", "https://raw.githubusercontent.com/92ganesh/Electride/master/sample.json", true);
		xmlhttp.setRequestHeader("Accept", "application/json");
		xmlhttp.send();
    }
    
    function calcDist(node1, node2){
    	return 1;
    }

    function createGraph(elements){
        let graph = new Map();
        let nodes = new Map();

        for(var i=0; i<elements.length; i++){
            if(elements[i].type=="node"){
                nodes.set(elements[i].id,{"lat":elements[i].lat, "lng":elements[i].lon});
                graph.set(elements[i].id, new Map());
            }else if(elements[i].type=="way"){
                for(var j=0;j<elements[i].nodes.length-1;j++){
                    graph.get(elements[i].nodes[j]).set(elements[i].nodes[j+1], calcDist(elements[i].nodes[j], elements[i].nodes[j+1]) );
                    graph.get(elements[i].nodes[j+1]).set(elements[i].nodes[j], calcDist(elements[i].nodes[j], elements[i].nodes[j+1]) );
                }
            }
        }
        
        dijkstra(nodes, graph, 7238785667, 2233648859);
        
    }
    
    function dijkstra(nodes, graph, source, destination){
    	let nodeInfo = new Map();
    	for (let node of nodes.keys()) {
    		nodeInfo.set(node,{minDist:Infinity, parent:null, visited:false});
    	}
    	
    	nodeInfo.get(source).minDist=0;
    	var queue = new Map();
    	queue.set(source,null);
    	
    	var itr=0;
    	while(queue.size>0){
    		var minDist = Infinity;  var minNode = -1;
    		for(let ele of queue.keys()){
    			if(nodeInfo.get(ele).minDist<minDist){
    				minDist = nodeInfo.get(ele).minDist;  minNode=ele;
    			}
    		}
    		
    		queue.delete(minNode);
    		nodeInfo.get(minNode).visited = true;
    		
    		for(let neighbour of graph.get(minNode).keys()){
    			if(nodeInfo.get(neighbour).visited==false){
    				queue.set(neighbour,null);
    				if( (nodeInfo.get(minNode).minDist + graph.get(minNode).get(neighbour)) < 
    						nodeInfo.get(neighbour).minDist ){
    					nodeInfo.get(neighbour).minDist = nodeInfo.get(minNode).minDist + graph.get(minNode).get(neighbour);
    					nodeInfo.get(neighbour).parent = minNode;
    				}
    				
    			}
    			
    		}
    	}
    	
    	var path = [];
    	curr = destination;
    	while(curr!=null){
    		path.push(nodes.get(curr));
    		curr = nodeInfo.get(curr).parent
    	}
    	
    	console.log(path);
    	
    }
    
   

</script>
</body>
</html>